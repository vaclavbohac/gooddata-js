---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/user.html">user</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/user.html">user</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v1.0.4</span>
                        <h1 class="file-heading">File: src/metadata.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // Copyright (C) 2007-2014, GoodData(R) Corporation. All rights reserved.
                        import {
                            isPlainObject,
                            get as _get,
                            chunk,
                            flatten
                        } from &#x27;lodash&#x27;;
                        import { ajax, get, post, parseJSON } from &#x27;./xhr&#x27;;
                        import { getIn } from &#x27;./util&#x27;;
                        
                        /**
                         * Functions for working with metadata objects
                         *
                         * @class metadata
                         * @module metadata
                         */
                        
                        /**
                         * Load all objects with given uris
                         * (use bulk loading instead of getting objects one by one)
                         *
                         * @method getObjects
                         * @param {String} projectId id of the project
                         * @param {Array} objectUris array of uris for objects to be loaded
                         * @return {Array} array of loaded elements
                         */
                        export function getObjects(projectId, objectUris) {
                            const LIMIT = 50;
                            const uri = &#x60;/gdc/md/${projectId}/objects/get&#x60;;
                        
                            const objectsUrisChunks = chunk(objectUris, LIMIT);
                        
                            const promises = objectsUrisChunks.map((objectUrisChunk) =&gt; {
                                const data = {
                                    get: {
                                        items: objectUrisChunk
                                    }
                                };
                        
                                return post(uri, {
                                    data: JSON.stringify(data)
                                }).then((r) =&gt; {
                                    if (!r.ok) {
                                        const err = new Error(r.statusText);
                                        err.response = r;
                                        throw err;
                                    }
                        
                                    return r.json();
                                }).then(result =&gt; _get(result, [&#x27;objects&#x27;, &#x27;items&#x27;]));
                            });
                        
                            return Promise.all(promises).then(flatten);
                        }
                        
                        /**
                         * Get MD objects from using2 resource. Include only objects of given types
                         * and take care about fetching only nearest objects if requested.
                         *
                         * @method getObjectUsing
                         * @param {String} projectId id of the project
                         * @param {String} uri uri of the object for which dependencies are to be found
                         * @param {Object} options objects with options:
                         *        - types {Array} array of strings with object types to be included
                         *        - nearest {Boolean} whether to include only nearest dependencies
                         * @return {jQuery promise} promise promise once resolved returns an array of
                         *         entries returned by using2 resource
                         */
                        export function getObjectUsing(projectId, uri, options = {}) {
                            const { types = [], nearest = false } = options;
                            const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                            const data = {
                                inUse: {
                                    uri,
                                    types,
                                    nearest: nearest ? 1 : 0
                                }
                            };
                        
                            return post(resourceUri, {
                                data: JSON.stringify(data)
                            }).then((r) =&gt; {
                                if (!r.ok) {
                                    const err = new Error(r.statusText);
                                    err.response = r;
                                    throw err;
                                }
                        
                                return r.json();
                            }).then(result =&gt; result.entries);
                        }
                        
                        /**
                         * Get MD objects from using2 resource. Include only objects of given types
                         * and take care about fetching only nearest objects if requested.
                         *
                         * @method getObjectUsingMany
                         * @param {String} projectId id of the project
                         * @param {Array} uris uris of objects for which dependencies are to be found
                         * @param {Object} options objects with options:
                         *        - types {Array} array of strings with object types to be included
                         *        - nearest {Boolean} whether to include only nearest dependencies
                         * @return {jQuery promise} promise promise once resolved returns an array of
                         *         entries returned by using2 resource
                         */
                        export function getObjectUsingMany(projectId, uris, options = {}) {
                            const { types = [], nearest = false } = options;
                            const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                            const data = {
                                inUseMany: {
                                    uris,
                                    types,
                                    nearest: nearest ? 1 : 0
                                }
                            };
                        
                            return post(resourceUri, {
                                data: JSON.stringify(data)
                            }).then((r) =&gt; {
                                if (!r.ok) {
                                    const err = new Error(r.statusText);
                                    err.response = r;
                                    throw err;
                                }
                        
                                return r.json();
                            }).then(result =&gt; result.useMany);
                        }
                        
                        /**
                         * Get additional information about elements specified by their uris
                         * &#x60;elementUris&#x60; is the array of uris of elements to be look-up
                         * Currently makes a request for each object, should be encapsulated
                         * to one call
                         *
                         * @method getElementDetails
                         * @param {Array} array of element uri strings
                         * @private
                         */
                        export function getElementDetails(elementUris) {
                            const fns = elementUris.map(uri =&gt; get(uri));
                        
                            return Promise.all(fns).then((...args) =&gt; {
                                const enriched = args.map((element) =&gt; {
                                    const root = element[0];
                                    if (root.attributeDisplayForm) {
                                        return {
                                            type: &#x27;attribute&#x27;,
                                            uri: root.attributeDisplayForm.meta.uri,
                                            formOf: root.attributeDisplayForm.content.formOf,
                                            name: root.attributeDisplayForm.meta.title
                                        };
                                    } else if (root.metric) {
                                        return {
                                            type: &#x27;metric&#x27;,
                                            uri: root.metric.meta.uri,
                                            name: root.metric.meta.title
                                        };
                                    }
                        
                                    return undefined;
                                });
                        
                                // override titles with related attribute title
                                const ids = {};
                                const indi = [];
                                let i = 0;
                                const formOfFns = [];
                        
                                enriched.forEach((el, idx) =&gt; {
                                    if (el.formOf) {
                                        formOfFns.push(get(el.formOf));
                                        ids[el.uri] = idx;
                                        indi[i] = idx;
                                        i += 1;
                                    }
                                });
                        
                                // all formOf are executed
                                return Promise.all(formOfFns).then((...formOfArgs) =&gt; {
                                    formOfArgs.forEach((arg, idx) =&gt; {
                                        // get element to owerwrite
                                        const which = indi[idx];
                                        const update = enriched[which];
                        
                                        update.name = arg[0].attribute.meta.title;
                                    });
                        
                                    return enriched;
                                });
                            });
                        }
                        
                        /**
                        * Reutrns all attributes in a project specified by projectId param
                        *
                        * @method getAttributes
                        * @param projectId Project identifier
                        * @return {Array} An array of attribute objects
                        */
                        export function getAttributes(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/attributes&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns all dimensions in a project specified by projectId param
                         *
                         * @method getDimensions
                         * @param projectId Project identifier
                         * @return {Array} An array of dimension objects
                         * @see getFolders
                         */
                        export function getDimensions(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/dimensions&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns project folders. Folders can be of specific types and you can specify
                         * the type you need by passing and optional &#x60;type&#x60; parameter
                         *
                         * @method getFolders
                         * @param {String} projectId - Project identifier
                         * @param {String} type - Optional, possible values are &#x60;metric&#x60;, &#x60;fact&#x60;, &#x60;attribute&#x60;
                         * @return {Array} An array of dimension objects
                         */
                        export function getFolders(projectId, type) {
                            function getFolderEntries(pId, t) {
                                const typeURL = t ? &#x60;?type=${t}&#x60; : &#x27;&#x27;;
                        
                                return get(&#x60;/gdc/md/${pId}/query/folders${typeURL}&#x60;).then(getIn(&#x27;query.entries&#x27;));
                            }
                        
                            switch (type) {
                                case &#x27;fact&#x27;:
                                case &#x27;metric&#x27;:
                                    return getFolderEntries(projectId, type);
                                case &#x27;attribute&#x27;:
                                    return getDimensions(projectId);
                                default:
                                    return Promise.all([
                                        getFolderEntries(projectId, &#x27;fact&#x27;),
                                        getFolderEntries(projectId, &#x27;metric&#x27;),
                                        getDimensions(projectId)
                                    ])
                                    .then((facts, metrics, attributes) =&gt; {
                                        return { fact: facts, metric: metrics, attribute: attributes };
                                    });
                            }
                        }
                        
                        /**
                         * Returns all facts in a project specified by the given projectId
                         *
                         * @method getFacts
                         * @param projectId Project identifier
                         * @return {Array} An array of fact objects
                         */
                        export function getFacts(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/facts&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns all metrics in a project specified by the given projectId
                         *
                         * @method getMetrics
                         * @param projectId Project identifier
                         * @return {Array} An array of metric objects
                         */
                        export function getMetrics(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/metrics&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns all metrics that are reachable (with respect to ldm of the project
                         * specified by the given projectId) for given attributes
                         *
                         * @method getAvailableMetrics
                         * @param {String} projectId - Project identifier
                         * @param {Array} attrs - An array of attribute uris for which we want to get
                         * availabale metrics
                         * @return {Array} An array of reachable metrics for the given attrs
                         * @see getAvailableAttributes
                         * @see getAvailableFacts
                         */
                        export function getAvailableMetrics(projectId, attrs) {
                            return post(&#x60;/gdc/md/${projectId}/availablemetrics&#x60;, {
                                data: JSON.stringify(attrs)
                            }).then(r =&gt; (r.ok ? r.json() : r)).then(r =&gt; r.entries);
                        }
                        
                        /**
                         * Returns all attributes that are reachable (with respect to ldm of the project
                         * specified by the given projectId) for given metrics (also called as drillCrossPath)
                         *
                         * @method getAvailableAttributes
                         * @param {String} projectId - Project identifier
                         * @param {Array} metrics - An array of metric uris for which we want to get
                         * availabale attributes
                         * @return {Array} An array of reachable attributes for the given metrics
                         * @see getAvailableMetrics
                         * @see getAvailableFacts
                         */
                        export function getAvailableAttributes(projectId, metrics) {
                            return post(&#x60;/gdc/md/${projectId}/drillcrosspaths&#x60;, {
                                body: JSON.stringify(metrics)
                            }).then(r =&gt; (r.ok ? r.json() : r)).then(r =&gt; r.drillcrosspath.links);
                        }
                        
                        /**
                         * Returns all attributes that are reachable (with respect to ldm of the project
                         * specified by the given projectId) for given metrics (also called as drillCrossPath)
                         *
                         * @method getAvailableFacts
                         * @param {String} projectId - Project identifier
                         * @param {Array} items - An array of metric or attribute uris for which we want to get
                         * availabale facts
                         * @return {Array} An array of reachable facts for the given items
                         * @see getAvailableAttributes
                         * @see getAvailableMetrics
                         */
                        export function getAvailableFacts(projectId, items) {
                            return post(&#x60;/gdc/md/${projectId}/availablefacts&#x60;, {
                                data: JSON.stringify(items)
                            }).then(r =&gt; (r.ok ? r.json() : r)).then(r =&gt; r.entries);
                        }
                        
                        /**
                         * Get details of a metadata object specified by its uri
                         *
                         * @method getObjectDetails
                         * @param uri uri of the metadata object for which details are to be retrieved
                         * @return {Object} object details
                         */
                        export function getObjectDetails(uri) {
                            return get(uri);
                        }
                        
                        /**
                         * Get folders with items.
                         * Returns array of folders, each having a title and items property which is an array of
                         * corresponding items. Each item is either a metric or attribute, keeping its original
                         * verbose structure.
                         *
                         * @method getFoldersWithItems
                         * @param {String} type type of folders to return
                         * @return {Array} Array of folder object, each containing title and
                         * corresponding items.
                         */
                        
                        export function getFoldersWithItems(projectId, type) {
                            // fetch all folders of given type and process them
                            return getFolders(projectId, type).then((folders) =&gt; {
                                // Helper function to get details for each metric in the given
                                // array of links to the metadata objects representing the metrics.
                                // @return the array of promises
                                function getMetricItemsDetails(array) {
                                    return Promise.all(array.map(getObjectDetails)).then((...metricArgs) =&gt; {
                                        return metricArgs.map(item =&gt; item.metric);
                                    });
                                }
                        
                                // helper mapBy function
                                function mapBy(array, key) {
                                    return array.map((item) =&gt; {
                                        return item[key];
                                    });
                                }
                        
                                // helper for sorting folder tree structure
                                // sadly @returns void (sorting == mutating array in js)
                                const sortFolderTree = (structure) =&gt; {
                                    structure.forEach((folder) =&gt; {
                                        folder.items.sort((a, b) =&gt; {
                                            if (a.meta.title &lt; b.meta.title) {
                                                return -1;
                                            } else if (a.meta.title &gt; b.meta.title) {
                                                return 1;
                                            }
                        
                                            return 0;
                                        });
                                    });
                                    structure.sort((a, b) =&gt; {
                                        if (a.title &lt; b.title) {
                                            return -1;
                                        } else if (a.title &gt; b.title) {
                                            return 1;
                                        }
                        
                                        return 0;
                                    });
                                };
                        
                                const foldersLinks = mapBy(folders, &#x27;link&#x27;);
                                const foldersTitles = mapBy(folders, &#x27;title&#x27;);
                        
                                // fetch details for each folder
                                return Promise.all(foldersLinks.map(getObjectDetails)).then((...folderDetails) =&gt; {
                                    // if attribute, just parse everything from what we&#x27;ve received
                                    // and resolve. For metrics, lookup again each metric to get its
                                    // identifier. If passing unsupported type, reject immediately.
                                    if (type === &#x27;attribute&#x27;) {
                                        // get all attributes, subtract what we have and add rest in unsorted folder
                                        getAttributes(projectId).then((attributes) =&gt; {
                                            // get uris of attributes which are in some dimension folders
                                            const attributesInFolders = [];
                                            folderDetails.forEach((fd) =&gt; {
                                                fd.dimension.content.attributes.forEach((attr) =&gt; {
                                                    attributesInFolders.push(attr.meta.uri);
                                                });
                                            });
                                            // unsortedUris now contains uris of all attributes which aren&#x27;t in a folder
                                            const unsortedUris =
                                                attributes
                                                    .filter(item =&gt; attributesInFolders.indexOf(item.link) === -1)
                                                    .map(item =&gt; item.link);
                                            // now get details of attributes in no folders
                                            return Promise.all(unsortedUris.map(getObjectDetails))
                                                .then((...unsortedAttributeArgs) =&gt; { // TODO add map to r.json
                                                    // get unsorted attribute objects
                                                    const unsortedAttributes = unsortedAttributeArgs.map(attr =&gt; attr.attribute);
                                                    // create structure of folders with attributes
                                                    const structure = folderDetails.map((folderDetail) =&gt; {
                                                        return {
                                                            title: folderDetail.dimension.meta.title,
                                                            items: folderDetail.dimension.content.attributes
                                                        };
                                                    });
                                                    // and append &quot;Unsorted&quot; folder with attributes to the structure
                                                    structure.push({
                                                        title: &#x27;Unsorted&#x27;,
                                                        items: unsortedAttributes
                                                    });
                                                    sortFolderTree(structure);
                        
                                                    return structure;
                                                });
                                        });
                                    } else if (type === &#x27;metric&#x27;) {
                                        const entriesLinks = folderDetails.map(entry =&gt; mapBy(entry.folder.content.entries, &#x27;link&#x27;));
                                        // get all metrics, subtract what we have and add rest in unsorted folder
                                        return getMetrics(projectId).then((metrics) =&gt; {
                                            // get uris of metrics which are in some dimension folders
                                            const metricsInFolders = [];
                                            folderDetails.forEach((fd) =&gt; {
                                                fd.folder.content.entries.forEach((metric) =&gt; {
                                                    metricsInFolders.push(metric.link);
                                                });
                                            });
                                            // unsortedUris now contains uris of all metrics which aren&#x27;t in a folder
                                            const unsortedUris =
                                                metrics
                                                    .filter(item =&gt; metricsInFolders.indexOf(item.link) === -1)
                                                    .map(item =&gt; item.link);
                        
                                            // sadly order of parameters of concat matters! (we want unsorted last)
                                            entriesLinks.push(unsortedUris);
                        
                                            // now get details of all metrics
                                            return Promise.all(entriesLinks.map(linkArray =&gt; getMetricItemsDetails(linkArray)))
                                                .then((...tree) =&gt; { // TODO add map to r.json
                                                    // all promises resolved, i.e. details for each metric are available
                                                    const structure = tree.map((treeItems, idx) =&gt; {
                                                        // if idx is not in foldes list than metric is in &quot;Unsorted&quot; folder
                                                        return {
                                                            title: (foldersTitles[idx] || &#x27;Unsorted&#x27;),
                                                            items: treeItems
                                                        };
                                                    });
                                                    sortFolderTree(structure);
                                                    return structure;
                                                });
                                        });
                                    } else {
                                        return Promise.reject();
                                    }
                        
                                    return undefined;
                                });
                            });
                        }
                        
                        /**
                         * Get identifier of a metadata object identified by its uri
                         *
                         * @method getObjectIdentifier
                         * @param uri uri of the metadata object for which the identifier is to be retrieved
                         * @return {String} object identifier
                         */
                        export function getObjectIdentifier(uri) {
                            function idFinder(obj) {
                                if (obj.attribute) {
                                    return obj.attribute.content.displayForms[0].meta.identifier;
                                } else if (obj.dimension) {
                                    return obj.dimension.content.attributes.content.displayForms[0].meta.identifier;
                                } else if (obj.metric) {
                                    return obj.metric.meta.identifier;
                                }
                        
                                throw Error(&#x27;Unknown object!&#x27;);
                            }
                        
                            if (!isPlainObject(uri)) {
                                return getObjectDetails(uri).then(data =&gt; idFinder(data));
                            }
                            return Promise.resolve(idFinder(uri));
                        }
                        
                        /**
                         * Get uri of an metadata object, specified by its identifier and project id it belongs to
                         *
                         * @method getObjectUri
                         * @param projectId id of the project
                         * @param identifier identifier of the metadata object
                         * @return {String} uri of the metadata object
                         */
                        export function getObjectUri(projectId, identifier) {
                            function uriFinder(obj) {
                                const data = (obj.attribute) ? obj.attribute : obj.metric;
                                return data.meta.uri;
                            }
                        
                            return ajax(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                method: &#x27;POST&#x27;,
                                body: {
                                    identifierToUri: [identifier]
                                }
                            }).then(parseJSON).then((data) =&gt; {
                                const found = data.identifiers.filter(i =&gt; i.identifier === identifier);
                        
                                if (found[0]) {
                                    return getObjectDetails(found[0].uri);
                                }
                                throw new Error(&#x60;Object with identifier ${identifier} not found in project ${projectId}&#x60;);
                            }).then((objData) =&gt; {
                                if (!objData.attributeDisplayForm) {
                                    return uriFinder(objData);
                                }
                                return getObjectDetails(objData.attributeDisplayForm.content.formOf).then((objectData) =&gt; {
                                    return uriFinder(objectData);
                                });
                            });
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

