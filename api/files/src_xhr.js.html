---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/user.html">user</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/user.html">user</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v1.0.4</span>
                        <h1 class="file-heading">File: src/xhr.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // Copyright (C) 2007-2013, GoodData(R) Corporation. All rights reserved.
                        import {
                            isPlainObject,
                            isFunction,
                            has,
                            merge
                        } from &#x27;lodash&#x27;;
                        import &#x27;isomorphic-fetch&#x27;;
                        import * as config from &#x27;./config&#x27;;
                        
                        /**
                         * Ajax wrapper around GDC authentication mechanisms, SST and TT token handling and polling.
                         * Inteface is same as original jQuery.ajax.
                        
                         * If token is expired, current request is &quot;paused&quot;, token is refreshed and request is retried and result.
                         * is transparently returned to original call.
                        
                         * Additionally polling is handled. Only final result of polling returned.
                         * @module xhr
                         * @class xhr
                         */
                        
                        const DEFAULT_POLL_DELAY = 1000;
                        
                        let tokenRequest;
                        let commonXhrSettings = {};
                        
                        /**
                         * Back compatible method for setting common XHR settings
                         *
                         * Usually in our apps we used beforeSend ajax callback to set the X-GDC-REQUEST header with unique ID.
                         *
                         * @param settings object XHR settings as
                         */
                        export function ajaxSetup(settings) {
                            commonXhrSettings = Object.assign({}, commonXhrSettings, settings);
                        }
                        
                        function simulateBeforeSend(settings) {
                            const xhr = {
                                setRequestHeader(key, value) {
                                    settings.headers.set(key, value);
                                }
                            };
                        
                            if (isFunction(settings.beforeSend)) {
                                settings.beforeSend(xhr);
                            }
                        }
                        
                        function enrichSettingWithCustomDomain(originalUrl, originalSettings, domain) {
                            let url = originalUrl;
                            const settings = originalSettings;
                            if (domain) {
                                // protect url to be prepended with domain on retry
                                if (originalUrl.indexOf(domain) === -1) {
                                    url = domain + originalUrl;
                                }
                                settings.mode = &#x27;cors&#x27;;
                                settings.credentials = &#x27;include&#x27;;
                            }
                        
                            return { url, settings };
                        }
                        
                        function continueAfterTokenRequest(url, settings) {
                            return tokenRequest.then((response) =&gt; {
                                if (!response.ok) {
                                    const err = new Error(&#x27;Unauthorized&#x27;);
                                    err.response = response;
                                    throw err;
                                }
                                tokenRequest = null;
                        
                                return ajax(url, settings); // eslint-disable-line no-use-before-define
                            }, (reason) =&gt; {
                                tokenRequest = null;
                                return reason;
                            });
                        }
                        
                        function createSettings(customSettings) {
                            const headers = new Headers({
                                Accept: &#x27;application/json; charset=utf-8&#x27;,
                                &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
                            });
                        
                            const settings = Object.assign({}, commonXhrSettings, customSettings);
                        
                            settings.pollDelay = (settings.pollDelay !== undefined) ? settings.pollDelay : DEFAULT_POLL_DELAY;
                        
                            settings.headers = headers;
                        
                            // TODO jquery compat - add to warnings
                            settings.body = (settings.data) ? settings.data : settings.body;
                            settings.mode = &#x27;same-origin&#x27;;
                            settings.credentials = &#x27;same-origin&#x27;;
                        
                            if (isPlainObject(settings.body)) {
                                settings.body = JSON.stringify(settings.body);
                            }
                        
                            return settings;
                        }
                        
                        function handleUnauthorized(originalUrl, originalSettings) {
                            if (!tokenRequest) {
                                // Create only single token request for any number of waiting request.
                                // If token request exist, just listen for it&#x27;s end.
                                const { url, settings } = enrichSettingWithCustomDomain(&#x27;/gdc/account/token&#x27;, createSettings({}), config.domain);
                        
                                tokenRequest = fetch(url, settings).then((response) =&gt; {
                                    // tokenRequest = null;
                                    // TODO jquery compat - allow to attach unauthorized callback and call it if attached
                                    // if ((xhrObj.status === 401) &amp;&amp; (isFunction(req.unauthorized))) {
                                    //     req.unauthorized(xhrObj, textStatus, err, deferred);
                                    //     return;
                                    // }
                                    // unauthorized handler is not defined or not http 401
                                    // unauthorized when retrieving token -&gt; not logged
                                    if (response.status === 401) {
                                        const err = new Error(&#x27;Unauthorized&#x27;);
                                        err.response = response;
                                        throw err;
                                    }
                        
                                    return response;
                                });
                            }
                            return continueAfterTokenRequest(originalUrl, originalSettings);
                        }
                        
                        function isLoginRequest(url) {
                            return url.indexOf(&#x27;/gdc/account/login&#x27;) !== -1;
                        }
                        
                        /**
                         * @param {Response} response
                         * @return {Promise} promise which resolves to result JSON ()
                         */
                        export const parseJSON = response =&gt; response.json();
                        
                        /**
                         * @param {Response} response see https://developer.mozilla.org/en-US/docs/Web/API/Response
                         * @return {Response} or {Error}
                         */
                        const checkStatus = (response) =&gt; {
                            if (response.status &gt;= 200 &amp;&amp; response.status &lt; 399) {
                                return response;
                            }
                        
                            if (response instanceof Error &amp;&amp; has(response, &#x27;response&#x27;)) {
                                throw response;
                            }
                        
                            const error = new Error(response.statusText);
                            error.response = response;
                            throw error;
                        };
                        
                        function handlePolling(url, settings) {
                            return new Promise((resolve, reject) =&gt; {
                                setTimeout(() =&gt; {
                                    ajax(url, settings).then(resolve, reject); // eslint-disable-line no-use-before-define
                                }, settings.pollDelay);
                            });
                        }
                        
                        export function ajax(originalUrl, tempSettings = {}) {
                            const firstSettings = createSettings(tempSettings);
                            const { url, settings } = enrichSettingWithCustomDomain(originalUrl, firstSettings, config.domain);
                        
                            simulateBeforeSend(settings);
                        
                            if (tokenRequest) {
                                return continueAfterTokenRequest(url, settings);
                            }
                        
                            return fetch(url, settings).then((response) =&gt; {
                                // If response.status id 401 and it was a login request there is no need
                                // to cycle back for token - login does not need token and this meand you
                                // are not authorized
                                if (response.status === 401) {
                                    if (isLoginRequest(url)) {
                                        const err = new Error(&#x27;Unauthorized&#x27;);
                                        err.response = response;
                                        throw err;
                                    }
                        
                                    return handleUnauthorized(url, settings);
                                }
                        
                                if (response.status === 202 &amp;&amp; !settings.dontPollOnResult) {
                                    // if the response is 202 and Location header is not empty, let&#x27;s poll on the new Location
                                    let finalUrl = url;
                                    const finalSettings = settings;
                                    if (response.headers.has(&#x27;Location&#x27;)) {
                                        finalUrl = response.headers.get(&#x27;Location&#x27;);
                                    }
                                    finalSettings.method = &#x27;GET&#x27;;
                                    delete finalSettings.data;
                                    delete finalSettings.body;
                                    return handlePolling(finalUrl, finalSettings);
                                }
                                return response;
                            }).then(checkStatus);
                        }
                        
                        function xhrMethod(method) {
                            return function methodFn(url, settings) {
                                const opts = merge({ method }, settings);
                        
                                return ajax(url, opts);
                            };
                        }
                        
                        /**
                         * Wrapper for xhr.ajax method GET
                         * @method get
                         */
                        export const get = (url, settings) =&gt; {
                            const opts = merge({ method: &#x27;GET&#x27; }, settings);
                        
                            return ajax(url, opts).then(parseJSON);
                        };
                        
                        /**
                         * Wrapper for xhr.ajax method POST
                         * @method post
                         */
                        export const post = xhrMethod(&#x27;POST&#x27;);
                        
                        /**
                         * Wrapper for xhr.ajax method PUT
                         * @method put
                         */
                        export const put = xhrMethod(&#x27;PUT&#x27;);
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

